name: CD Pipeline

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

env:
  DOCKER_REGISTRY: ghcr.io
  DOCKER_IMAGE: ghcr.io/${{ github.repository }}
  KUBE_NAMESPACE: teknofest-egitim

jobs:
  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://staging.teknofest-egitim.example.com
    steps:
      - uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name teknofest-cluster --region eu-west-1

      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/teknofest-api \
            teknofest-api=${{ env.DOCKER_IMAGE }}:main \
            -n ${{ env.KUBE_NAMESPACE }}-staging
          
          kubectl rollout status deployment/teknofest-api \
            -n ${{ env.KUBE_NAMESPACE }}-staging \
            --timeout=600s

      - name: Run smoke tests
        run: |
          curl -f https://staging.teknofest-egitim.example.com/health || exit 1

      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Staging deployment ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: https://teknofest-egitim.example.com
    steps:
      - uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name teknofest-cluster --region eu-west-1

      - name: Get the version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Blue-Green Deployment
        run: |
          # Create new deployment (green)
          kubectl create deployment teknofest-api-green \
            --image=${{ env.DOCKER_IMAGE }}:${{ steps.get_version.outputs.VERSION }} \
            -n ${{ env.KUBE_NAMESPACE }}
          
          # Wait for green deployment to be ready
          kubectl rollout status deployment/teknofest-api-green \
            -n ${{ env.KUBE_NAMESPACE }} \
            --timeout=600s
          
          # Run health checks on green deployment
          kubectl exec -it deploy/teknofest-api-green \
            -n ${{ env.KUBE_NAMESPACE }} \
            -- curl -f http://localhost:8000/health || exit 1
          
          # Switch traffic to green
          kubectl patch service teknofest-api \
            -n ${{ env.KUBE_NAMESPACE }} \
            -p '{"spec":{"selector":{"version":"green"}}}'
          
          # Delete old blue deployment
          kubectl delete deployment teknofest-api-blue \
            -n ${{ env.KUBE_NAMESPACE }} \
            --ignore-not-found=true
          
          # Rename green to blue for next deployment
          kubectl patch deployment teknofest-api-green \
            -n ${{ env.KUBE_NAMESPACE }} \
            -p '{"metadata":{"name":"teknofest-api-blue"}}'

      - name: Run production tests
        run: |
          # Health check
          curl -f https://teknofest-egitim.example.com/health || exit 1
          
          # API tests
          python -m pytest tests/test_production_integration.py -v

      - name: Create rollback job
        if: failure()
        run: |
          kubectl patch service teknofest-api \
            -n ${{ env.KUBE_NAMESPACE }} \
            -p '{"spec":{"selector":{"version":"blue"}}}'
          
          kubectl delete deployment teknofest-api-green \
            -n ${{ env.KUBE_NAMESPACE }} \
            --ignore-not-found=true

      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment ${{ job.status }} for version ${{ steps.get_version.outputs.VERSION }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()

  # Deploy to Cloud Run (Alternative)
  deploy-cloudrun:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'production' || startsWith(github.ref, 'refs/tags/v')
    environment:
      name: cloudrun-production
      url: https://teknofest-api-xyz.run.app
    steps:
      - uses: actions/checkout@v4

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Configure Docker for GCR
        run: |
          gcloud auth configure-docker

      - name: Build and Push to GCR
        run: |
          docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/teknofest-api:${{ github.sha }} .
          docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/teknofest-api:${{ github.sha }}

      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy teknofest-api \
            --image gcr.io/${{ secrets.GCP_PROJECT_ID }}/teknofest-api:${{ github.sha }} \
            --platform managed \
            --region europe-west1 \
            --allow-unauthenticated \
            --set-env-vars "ENVIRONMENT=production" \
            --min-instances 1 \
            --max-instances 100 \
            --memory 2Gi \
            --cpu 2

  # Deploy to Azure Container Instances
  deploy-azure:
    name: Deploy to Azure
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'staging'
    environment:
      name: azure-staging
      url: https://teknofest-staging.azurewebsites.net
    steps:
      - uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push to ACR
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/teknofest-api:${{ github.sha }} .
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/teknofest-api:${{ github.sha }}

      - name: Deploy to Azure Container Instances
        uses: azure/aci-deploy@v1
        with:
          resource-group: teknofest-rg
          dns-name-label: teknofest-api
          image: ${{ secrets.ACR_LOGIN_SERVER }}/teknofest-api:${{ github.sha }}
          name: teknofest-api
          location: 'West Europe'
          cpu: 2
          memory: 4

  # Deploy to Heroku
  deploy-heroku:
    name: Deploy to Heroku
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'development'
    environment:
      name: heroku-dev
      url: https://teknofest-dev.herokuapp.com
    steps:
      - uses: actions/checkout@v4

      - name: Deploy to Heroku
        uses: akhileshns/heroku-deploy@v3.12.14
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: teknofest-dev
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          usedocker: true
          docker_heroku_process_type: web

  # Database Migration
  migrate-database:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install alembic psycopg2-binary

      - name: Run migrations
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        run: |
          alembic upgrade head

  # Cleanup
  cleanup:
    name: Cleanup Old Resources
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()
    steps:
      - name: Clean old Docker images
        run: |
          echo "Cleaning old Docker images from registry"
          # Add cleanup logic here

      - name: Clean old Kubernetes resources
        run: |
          echo "Cleaning old Kubernetes resources"
          # kubectl delete pods --field-selector status.phase=Failed -n ${{ env.KUBE_NAMESPACE }}